name: Entrega Continua

on:
  release:
    types: [published]

jobs:
  check-ci:
    runs-on: ubuntu-latest 
    steps:
      - name: Check if CI passed
        uses: actions/github-script@v6
        with:
          script: |
            const requiredChecks = [
              "Build",
              "Tests Unitarios e Integracion",
              "Tests End-to-End",
            ];

            const { data: { check_runs } } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
            });

            for (const checkName of requiredChecks) {
              const check = check_runs.find(c => c.name === checkName);
              if (!check || check.conclusion !== 'success') {
                core.setFailed(`Check "${checkName}" must pass before deployment`);
              }
            }
  build-and-push:
    needs: check-ci
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKERHUB_USERNAME }}/eventhub
          tags: |
            type=ref,event=tag
            type=raw,value=latest
          labels: |
            org.opencontainers.image.title=EventHub
            org.opencontainers.image.description=Aplicaci√≥n web para venta de entradas
            org.opencontainers.image.vendor=UTN-FRLP

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ${{ secrets.DOCKERHUB_USERNAME }}/eventhub:${{ github.ref_name }}
          format: spdx-json
          output-file: sbom.spdx.json
  
      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom.spdx.json
  
  deploy-render:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Deploy and wait for Render
        id: deploy
        uses: actions/github-script@v6
        with:
          script: |
            const deployResponse = await fetch('https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/deploys', {
              method: 'POST',
              headers: {
                'Authorization': 'Bearer ${{ secrets.RENDER_API_KEY }}',
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                clearCache: 'clear'
              })
            });

            if (!deployResponse.ok) {
              const error = await deployResponse.text();
              core.setFailed(`Deploy failed: ${error}`);
              return;
            }

            const deployData = await deployResponse.json();
            const deployId = deployData.id;
            console.log(`Deploy initiated. ID: ${deployId}`);

            const maxWaitTime = 10 * 60 * 1000; // 10 minutos
            const pollInterval = 30 * 1000; // 30 segundos
            const startTime = Date.now();

            while (Date.now() - startTime < maxWaitTime) {
              const response = await fetch(`https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/deploys/${deployId}`, {
                headers: {
                  'Authorization': 'Bearer ${{
                    secrets.RENDER_API_KEY
                  }}`
                }
              });

              const deploy = await response.json();
              console.log(`Deploy status: ${deploy.status}`);

              if (deploy.status === 'live') {
                console.log('Deployment successful!');
                return;
              } else if (deploy.status === 'build_failed' || deploy.status === 'deploy_failed') {
                core.setFailed(`Deployment failed with status: ${deploy.status}`);
                return;
              }

              await new Promise(resolve => setTimeout(resolve, pollInterval));
            }

            core.setFailed('Deployment timed out');

